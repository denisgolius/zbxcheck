#!/usr/bin/python
# -*- coding: UTF-8 -*-

import sys
import time
from optparse import OptionParser
import pywbem
import json
import re
import socket

VERSION = '1.0.0'
ZBX_ERROR = 'ZBX_NOTSUPPORTED'
verbose = False

# please increase Timeout=15 in zabbix_server.conf
TIMEOUT = 10
socket.setdefaulttimeout(TIMEOUT)

# wbem default namespcae
NAMESPACE = 'root/cimv2'
COMPONENT_MAP = {
    'cpu':  ('CIM_Processor',),
    'mem':  ('CIM_Memory',),
    'fan':  ('CIM_Fan',),
    'ps':   ('CIM_PowerSupply',),
    'temp': ('CIM_NumericSensor',),
    'raid': ('VMware_Controller',),
    'disk': ('VMware_StorageExtent', 'OMC_DiscreteSensor')
}


def output(message):
    if verbose:
        print '%s %s' % (time.strftime('%Y%m%d %H:%M:%S'), message)


def to_json(items):
    discovery = {}
    discovery['data'] = items
    if verbose:
        return json.dumps(discovery, encoding='utf-8', indent=4)
    else:
        return json.dumps(discovery, encoding='utf-8')


def discover_wbem(args):
    hostname = args[0]
    username = args[1]
    password = args[2]
    compname = args[3]

    items = []

    try:
        conn = pywbem.WBEMConnection(
            'https://' + hostname, (username, password), NAMESPACE)
        for cname in COMPONENT_MAP[compname]:
            output('scan class: %s' % cname)
            instances = conn.EnumerateInstances(cname)
            for i in instances:
                output('scan for instance: %s' % i)
                # skip any items which HealthState is null or unknow
                if i['HealthState'] is None and i['HealthState'] != 0:
                    continue
                elif cname == 'CIM_Memory' and i['Name'] != 'System Memory':
                    continue
                elif cname == 'CIM_NumericSensor' and i['SensorType'] != 2:
                    continue
                elif cname == 'OMC_DiscreteSensor' and not (
                    i['IpmiSensorType'] == 13 and
                    re.search('Drive Fault$', i['ElementName'])
                ):
                    continue
                item = {}
                item['{#CNAME}'] = i['CreationClassName']
                item['{#ENAME}'] = i['ElementName']
                if 'DeviceID' in i.keys():
                    item['{#DEVID}'] = i['DeviceID']
                else:
                    item['{#DEVID}'] = ''
                output('get item: %s' % item)
                items.append(item)
            # if get items, stop scan other class
            if len(items) > 0:
                break
    except Exception as detail:
        print 'error: %s' % detail
        return ZBX_ERROR
    return to_json(items)


def get_wbem(args):
    hostname = args[0]
    username = args[1]
    password = args[2]
    cname = args[3]
    ename = args[4]
    devid = args[5]

    try:
        conn = pywbem.WBEMConnection(
            'https://' + hostname, (username, password), NAMESPACE)
        if devid == '':
            output('scan element: %s' % ename)
            instances = conn.EnumerateInstances(cname)
            for instance in instances:
                output('scan for instance: %s' % instance)
                if instance['ElementName'] == ename:
                    return instance['HealthState']
        else:
            output('scan device: %s' % devid)
            names = conn.EnumerateInstanceNames(cname)
            for name in names:
                output('scan for instance name: %s' % name)
                if name['DeviceID'] == devid:
                    instance = conn.GetInstance(name)
                    return instance['HealthState']
    except Exception as detail:
        print 'error: %s' % detail
        return ZBX_ERROR
    print 'error: no matching instance'
    return ZBX_ERROR


def get_opt():
    global VERSION, verbose
    usage = '''
    %prog -d hostname user password component [-v]
    or
    %prog -g hostname user password cname ename devid [-v]

    component include:
        cpu     --CPU
        mem     --Memory
        fan     --Fan
        ps      --PowerSupply
        temp    --Temperature Sensor
        raid    --RAID Controller
        disk    --Physical Disk'''

    parser = OptionParser(usage=usage, version=VERSION)
    parser.add_option('-d', '--discover', action='store_true',
                      dest='f_discover', default=False,
                      help='discover instances of the component')
    parser.add_option('-g', '--get', action='store_true',
                      dest='f_get', default=False,
                      help='get instance status')
    parser.add_option('-v', '--verbose', action='store_true',
                      dest='f_verbose', default=False,
                      help='print verbose infomation')
    (options, args) = parser.parse_args()

    verbose = options.f_verbose
    check_opt = False

    # check options:
    # -d -g option can not specified both or both not
    if options.f_discover == options.f_get:
        print 'you must specified: -d or -g'
    # user must specified 4 params in -d option
    elif options.f_discover:
        if len(args) < 4:
            print 'too few parameters'
        else:
            # valide component name
            if args[3] not in COMPONENT_MAP.keys():
                print 'component name is not correct'
            else:
                check_opt = True
                method = discover_wbem
    # user must specified 6 params in -g option
    elif options.f_get:
        if len(args) < 6:
            print 'too few parameters'
        else:
            check_opt = True
            method = get_wbem

    # if option check failed, exit
    if not check_opt:
        parser.print_help()
        sys.exit(-1)
    else:
        return (method, args)


if __name__ == '__main__':
    method, args = get_opt()
    print method(args)
